// CSE240 Fall 2021 HW10
// Tyler Fichiera
// Programming environment used: g++


// READ BEFORE YOU START:
// You are given a partially completed program that creates a list of books.
// Each book has name, price and library type (hayden or noble).
// This information is stored as an object of Book class. Class defined in book.h
// The classes Hayden and Noble are child classes of the Book class.
// When adding a new book, these child classes are used to make the book node of the list.
// So each node in the list is actually an object of either Hayden or Noble class.

//
// To begin, you should trace through the given code and understand how it works.
// Please read the instructions above each required function and follow the directions carefully.
// Do not modify given code.

// You can assume that all input is valid:
// Valid name:	String containing alphabetical letters
// Valid number: a positive integer

#include <iostream>
#include <fstream>
#include <string>
#include "Container.h"
#include "book.h"
#include "noble.h"
#include "hayden.h"

using namespace std;

// functions already implemented:
void executeAction(char c);
Book* searchBook(string name_input);

// functions that need implementation:
void addBook(string name_input, double price_input, libraryType type); // 7 points
void displayList(); // 4 points
void save(string fileName); // 7 points
void load(string fileName); // 7 points

Container* list = NULL; // global list

int main() {
	char c = 'i'; // initialized to a dummy value

  	// During first execution, there will be no list.txt in source directory. list.txt is generated by save() while exiting the program.
	load("list.txt");
			
	do {
		cout << "\nCSE240 HW10\n";
		cout << "Please enter your selection:\n";
		cout << "\t a: add a new book\n";
		cout << "\t d: display book list\n";
		cout << "\t c: change unit price of a book\n";
		cout << "\t q: quit\n";
		cin >> c;
		cin.ignore();
		executeAction(c);
	} while (c != 'q');

	save("list.txt");

	list = NULL;

	return 0;
}

// Ask for details from user for the given selection and perform that action
// Read the function case by case
void executeAction(char c) {
	string name_input;
	double price_input;
	int type_input = 2;
	libraryType type;
	Book* bookResult = NULL;

	switch (c) {
		case 'a': // add book
			// input book details from user
			cout << endl << "Enter book name: ";
			getline(cin, name_input);
			cout << "Enter new unit price: ";
			cin >> price_input;
			cin.ignore();

			while (!(type_input == 0 || type_input == 1)) {
				cout << "Enter book type: " << endl;
				cout << "0. Hayden " << endl;
				cout << "1. Noble" << endl;
				cin >> type_input;
				cin.ignore();
			}
			type = (libraryType)type_input;

			// searchBook() will return the book object if found, else returns NULL
			bookResult = searchBook(name_input);
			if (bookResult == NULL) {
				addBook(name_input, price_input, type);
				cout << endl << "Book added to list!" << endl << endl;
			} else {
				cout << endl << "Book already present in the list!" << endl << endl;
			}

			break;

		case 'd': // display the list
			displayList();
			break;

		case 'c': // change price
			cout << endl << "Enter book name: ";
			getline(cin, name_input);
			// searchBook() will return the book node if found, else returns NULL
			bookResult = searchBook(name_input);
			if (bookResult == NULL) {
				cout << endl << "Book not in list!" << endl << endl;
			} else {
				// if book exists in the list, then ask user for new price
				cout << endl << "Enter new price: ";
				cin >> price_input;
				cin.ignore();

				// Q3c Call changePrice() here   (1 point)
				// 'bookResult' contains the book whose 'price' is to be changed.
				// 'price_input' contains the new price of the book.
				// Call the function with appropriate arguments.

				cout << endl << "Price changed!" << endl << endl;
			}
			break;

		case 'q': // quit
			break;

		default: cout << c << " is invalid input!\n";
	}
}

// No implementation needed here, however it may be helpful to review this function
Book* searchBook(string name_input) {
	Container* tempList = list; // work on a copy of 'list'

	// parse till end of list
	while (tempList != NULL) {
		if (tempList->book->getName() == name_input) {
			return tempList->book; // return the book if found
		}

		tempList = tempList->next; // parse the list
	}

	return NULL; // return NULL if book not found in list
}

// Q3b: Define Friend Function changePrice()  (3 points)
// Define the function changePrice() that is declared in book.h file.
// This function sets the new 'price' of the book. The book object and new price is to be passed as function arguments.
// Use 'd' display option after using 'c' option to verify.
// You will need to implement add() and displayList() before you test this function.
void changePrice(Book *book, double newPrice) {
	book->price = newPrice;
}

// Q4: addBook  (7 points)
// This function is used to add a new book to the global linked list 'list'. You may add the new book to head or tail of the list. (Sample solution adds to tail)
// libraryType 'type' can be hayden or noble. You will need to use the function argument �type� to determine which constructor to use to create new book node.
// For example, if the user enters type as 'noble', then you need to use Noble class and constructor to create new book node and add it to the list.
// NOTE: In executeAction(), searchBook() is called before this function. Therefore no need to check here if the book exists in the list.
//       See how this function is called in case 'a' of executeAction()
void addBook(string name_input, double price_input, libraryType type) {
	Container* tempList = list; // work on a copy of 'list'

	// create book based on type enum
	Book *book;
	if (type == hayden) {
		book = new Hayden(name_input, price_input, type);
	} else {
		book = new Noble(name_input, price_input, type);
	}

	// create new container and add new book to head
	Container *tempContainer = new Container();
	tempContainer->book = book;
	tempContainer->next = list;

	// set current list to new container
	list = tempContainer;
}

// Q5: displayList	(4 points)
// This function displays the list of book and their details (name, price, library name)
// Parse the list and use the class member function to display the book info.
// See expected output in the question file.
void displayList() {
	Container *tempList = list; // work on a copy of 'list'

	// parse until end of list
	while (tempList != NULL) {
		tempList->book->displayBook();
		tempList = tempList->next; // parse the list
	}
}

// Q6: save  (7 points)
// Save the linked list of books to a file list.txt using ofstream.
// You will need to save the number of books in linked list. That will help in load() when reading the file.
// One format to store is:
// <no. of books>
// <Book1 name>
// <Book1 price>
// <Book1 type>
// <Book2 name>
// <Book2 price>
// <Book2 type>
// and so on..
// You may store the list in another format if you wish. You need to read the file in load() the same way that it is saved in save().
// This function is called when exiting the program (end of main()).
// Hint: You may want to cast the enum �libraryType� to an int before writing it to the file.
void save(string fileName) {
	Container *tempList = list; // work on a copy of 'list'

	// open file
	ofstream listFile;
	listFile.open(fileName);

	// parse until end of list
	while (tempList != NULL) {
		// add into line by line to the txt file
		listFile << tempList->book->getName() << "\n";
		listFile << tempList->book->getPrice() << "\n";
		listFile << tempList->book->getLibraryType() << "\n";
		tempList = tempList->next; // parse the list
	}

	// close file
	listFile.close();
}

// Q7: load (7 points)
// Load the linked list of books from the file using ifstream.
// You will need to create the linked list in the same order that is was saved to the file in save().
// First, read the number of books saved in the file.
// Then, for every book you will need to create a new Book node depending on book type. You may add the book to head or tail of the list. 
// Hint: If you casted the enum 'libraryType' to an int, you will need to cast it back to 'libraryType' when making the book node.
// This function is called at the beginning of main().
void load(string fileName) {
	// open file
	ifstream listFile;
	listFile.open(fileName);

	// return if the file does not exist (first run of program)
	if (!listFile.is_open()) {
		return;
	}

	// read elements line by line
	string name, price, type;
	while (getline(listFile, name))  {
		getline(listFile, price);
		getline(listFile, type);

		// add book to linked list using helper method
		// convert strings to respective types
		addBook(name, stod(price), type == "0" ? hayden : noble);
	}

	/* 
		Note: since my addBook function adds new elements to the head and this 
			function reads the txt file from top to bottom, the linked list is
			reversed every time the program is ran. I assume this way of doing
			it is still valid since the instructions say elements can be added to
			head or tail and it does not produce any semantic errors.
	*/
}
